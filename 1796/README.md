# Educational Codeforces Round 144 (Rated for Div. 2)

> Date: Mar. 11, 2023 (practice)  
> Problem Set: https://codeforces.com/contest/1796  

As the "flag" I set on [round #854](../1799/),
here comes the first (practice) contest in March.
This time I solved 3 of 6 up to \*1500 but with lots of failed submissions, so I think I'll drop ratings if in a formal contest ðŸ˜…

Problem A "Typical Interview Problem" ask to check if a given string is part of an infinity pattern which is described by "math" and actially is "FBFFBFFB".
Because the given string and pattern string is both very short, it shoud be enough to use 2 for-loops to solve this.
By the way this problem could be more difficult by matching numbers instead of FB letters,
for example "BFBFFBFF" is bad because the last "FB" in pattern is generated by "15" and should always be together.

Problem B "Asterisk-Minor Template" ask to give a common template for 2 string, which is more like a brain twister.
The only limitation is that "\*" could not be more than letters, yeah, no more than letters.
That means if we found a common substring in length 2,
we can build a template like "\*co\*" even they have a longer common substring like "leetcode" and "codeforces".
And if they have the same prefix or suffix, the template could be "p\*" or "\*x".
Since the string has max length at 50, I think it should be enough with 2 for-loops again,
and actually I saw other one's codes passed like that after contest, but I got a TLE.
So I added a 26 x 26 bitset to cache the exist length 2 substring of a, and check if any one matched in b.

Problem C "Maximum Set" ask to find the number of an available number set with the max size.
Because each number in the set should divide any other, we have to build this set like `f(i) = f(i-1) * k(i), f(0) = any number in range`.
To make this sequence as long as possible, it's better to set the least number as f(0) and let all k(i) be 2, so the max size should be log2(r-l).

Then find the available amount of set.
It's easy to prove that k(i) should include at most one 3 and others should be 2,
because 4 can be devided into 2 x 2 to build a longer sequence, and 3 x 3 can be replaced to 2 x 2 x 2.
So here we have the function:
```
count = Sum(1, if i * 2^(s-1) <= r) + Sum(size-1, if i * 2^(s-1) * 1.5 <= r)
```

In order to prevent exceeding integer limits, I also used the double-and-add method to calculate second "if" above, just like exponentiating by squaring.
But I guess using `int64_t` is enough, but didn't try.

Allright, that's all I submit today. Hope I have some time to learn problem D next ðŸ˜„
